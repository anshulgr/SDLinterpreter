module Appearence.Camera where
import Text.ParserCombinators.Parsec
import Data.Char
import Graphics.UI.GLUT
import Graphics.Rendering.OpenGL
import Graphics.Rendering.OpenGL.GL.CoordTrans
import Data.List

-- | Creates tuple (attribute name, co-ordinates) for each attribute of camera 
parseInput :: [String] -> [(String,GLdouble,GLdouble,GLdouble)]
parseInput [] = []
parseInput (xs:xss) =if ((isInfixOf "location" xs) || (isInfixOf "look_at" xs ) || (isInfixOf "direction" xs ) )
                         then
                            let (l1 , interm) = splitAt (head(elemIndices '<' xs)) xs
                               in
                                 let (x1,y1,z1) = getLocation (fst (splitAt (head(elemIndices '>' xs)) interm))
                                   in do (l1 ,x1,y1,z1) :(parseInput xss) 
                         else
                           if (isInfixOf "angle" xs)
                            then
                             let angle =  ( snd (splitAt (head (elemIndices ' ' (tail xs))) ( tail (xs) ) ) )
                               in ("angle",(read angle),0.0,0.0) :(parseInput xss) 
                            
                            else
                              if ( isInfixOf "up" xs)
                               then
                                 let (l1 , interm) = splitAt (head(elemIndices '<' xs)) xs
                                  in
                                   let (x1,y1,z1) = getLocation (fst (splitAt (head(elemIndices '>' xs)) interm))
                                     in do (l1 ,x1,y1,z1) :(parseInput xss) 
                               else
                                if ( isInfixOf "right" xs)
                                 then
                                   let (l1 , interm) = splitAt (head(elemIndices '<' xs)) xs
                                    in
                                     let (x1,y1,z1) = getLocation (fst (splitAt (head(elemIndices '>' xs)) interm))
                                       in do (l1 ,x1,y1,z1) :(parseInput xss) 
                                 else
                                      parseInput xss

-- | Calls HOpenGL frustum setting attributes top, bottom, left, right, near, far
callFrustum ( Vertex3 px py pz) (Vector3 ux uy uz) (Vector3 rx ry rz) (Vector3 dx dy dz) = do
		matrixMode $= Projection
		loadIdentity
		depthFunc $= Just Less
		sz<-get screenSize
                viewport   $= (Position 0 0, sz)
		let
			ul = sqrt (ux*ux + uy*uy + uz*uz)
			rl = sqrt (rx*rx + ry*ry + rz*rz)
			dl = sqrt (dx*dx + dy*dy + dz*dz)
		        near = 0.1
		        far = 100
                 	xview = realToFrac (rl / dl * near) *(-6.5)
			yview = realToFrac (ul / dl * near) * (3.5)
		
		frustum (-xview) xview (-yview) yview (realToFrac near) (realToFrac far)
		
		matrixMode $= (Modelview (-11))
		
-- | Obtains attributes of the camera
cameraFound xs = do
                  let location  = (findLoc (parseInput xs))
                      lookat    = findLookat (parseInput xs)
                      direction = findUp (parseInput xs)
                    in setPointOfView location  lookat direction
                  callFrustum ( findLoc ( parseInput xs)) ( findUp ( parseInput xs)) (findRight ( parseInput xs)) (findDirection ( parseInput xs)) 
                  
-- | Creates Location Vertex
findLoc res = let (a,x,y,z) = head ( filter (\(m,n,p,q) -> (isInfixOf "location" m ) ) res)
                in (Vertex3 (x) (y) (z))

-- | Creates Look At Vertex
findLookat res = let (a,x,y,z) = head ( filter (\(m,n,p,q) -> (isInfixOf "look_at" m ) ) res)
                  in (Vertex3 (x) y ((z)))

-- | Creates Direction Vertex
findDirection res = let (a,x,y,z) =head ( filter (\(m,n,p,q) -> (isInfixOf "direction" m ) ) res)
                     in (Vector3 (x) (y) (z))

-- | Creates Angle Vertex
findAngle res = let (a,x,y,z) =head ( filter (\(m,n,p,q) -> (isInfixOf "angle" m ) ) res)
                     in (x)

-- | Creates Up Vertex
findUp res = let (a,x,y,z) =head ( filter (\(m,n,p,q) -> (isInfixOf "up" m ) ) res)
                     in (Vector3 x y (z))

-- | Creates Right Vertex
findRight res = let (a,x,y,z) =head ( filter (\(m,n,p,q) -> (isInfixOf "right" m ) ) res)
                     in (Vector3 (x) (y) ((z)))

-- | Separates x,y,z Co-ordinates and creates a tuple out of it
getLocation :: String -> (GLdouble,GLdouble,GLdouble)
getLocation xs = let (r,rs)   = getVal (tail xs)
                    in 
                      let (g, gs) = getVal rs
                        in 
                          let (b,bs) = getVal gs
                            in ((read r),(read g),(read b))

-- | Separates single co-ordinate and returns remaining list
getVal :: String -> (String,String)
getVal (x:xs) = do
                  if ((x == ',') || (x == '>'))
                    then ([],xs)
                    else
                     if (isSpace x)
                      then (fst(getVal xs),snd(getVal xs))
                      else (x:fst(getVal xs),snd(getVal xs))

-- | Sets viewport for camera
setPointOfView location lookat direction = do lookAt (Vertex3 0.6 6.0 (-1.5)) (Vertex3 1.0 (0.95) (1.0)) (Vector3 0.0 (-1.5) 6.0)
                                              --  lookAt location lookat  (direction)

